/**
 * Generated by orval v6.9.6 ðŸº
 * Do not edit manually.
 * Swagger Petstore
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 * OpenAPI spec version: 1.0.6
 */
import { useQuery, useMutation } from 'react-query';
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey,
} from 'react-query';
import type {
  ApiResponse,
  UploadFileBody,
  PetBody,
  Pet,
  FindPetsByStatusParams,
  FindPetsByTagsParams,
  UpdatePetWithFormBody,
  Order,
  GetInventory200,
  UserArrayBody,
  User,
  LoginUserParams,
} from './model';
import { customInstance } from './axios-instance';

/**
 * @summary uploads an image
 */
export const uploadFile = (petId: number, uploadFileBody: UploadFileBody) => {
  const formData = new FormData();
  if (uploadFileBody.additionalMetadata !== undefined) {
    formData.append('additionalMetadata', uploadFileBody.additionalMetadata);
  }
  if (uploadFileBody.file !== undefined) {
    formData.append('file', uploadFileBody.file);
  }

  return customInstance<ApiResponse>({
    url: `/pet/${petId}/uploadImage`,
    method: 'post',
    headers: { 'Content-Type': 'multipart/form-data' },
    data: formData,
  });
};

export type UploadFileMutationResult = NonNullable<Awaited<ReturnType<typeof uploadFile>>>;
export type UploadFileMutationBody = UploadFileBody;
export type UploadFileMutationError = unknown;

export const useUploadFile = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadFile>>,
    TError,
    { petId: number; data: UploadFileBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadFile>>,
    { petId: number; data: UploadFileBody }
  > = (props) => {
    const { petId, data } = props ?? {};

    return uploadFile(petId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof uploadFile>>,
    TError,
    { petId: number; data: UploadFileBody },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * @summary Add a new pet to the store
 */
export const addPet = (petBody: PetBody) => {
  return customInstance<unknown>({
    url: `/pet`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: petBody,
  });
};

export type AddPetMutationResult = NonNullable<Awaited<ReturnType<typeof addPet>>>;
export type AddPetMutationBody = PetBody;
export type AddPetMutationError = void;

export const useAddPet = <TError = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addPet>>,
    TError,
    { data: PetBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPet>>, { data: PetBody }> = (
    props
  ) => {
    const { data } = props ?? {};

    return addPet(data);
  };

  return useMutation<Awaited<ReturnType<typeof addPet>>, TError, { data: PetBody }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * @summary Update an existing pet
 */
export const updatePet = (petBody: PetBody) => {
  return customInstance<unknown>({
    url: `/pet`,
    method: 'put',
    headers: { 'Content-Type': 'application/json' },
    data: petBody,
  });
};

export type UpdatePetMutationResult = NonNullable<Awaited<ReturnType<typeof updatePet>>>;
export type UpdatePetMutationBody = PetBody;
export type UpdatePetMutationError = void;

export const useUpdatePet = <TError = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePet>>,
    TError,
    { data: PetBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePet>>, { data: PetBody }> = (
    props
  ) => {
    const { data } = props ?? {};

    return updatePet(data);
  };

  return useMutation<Awaited<ReturnType<typeof updatePet>>, TError, { data: PetBody }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * Multiple status values can be provided with comma separated strings
 * @summary Finds Pets by status
 */
export const findPetsByStatus = (params: FindPetsByStatusParams, signal?: AbortSignal) => {
  return customInstance<Pet[]>({ url: `/pet/findByStatus`, method: 'get', params, signal });
};

export const getFindPetsByStatusQueryKey = (params: FindPetsByStatusParams) => [
  `/pet/findByStatus`,
  ...(params ? [params] : []),
];

export type FindPetsByStatusQueryResult = NonNullable<Awaited<ReturnType<typeof findPetsByStatus>>>;
export type FindPetsByStatusQueryError = void;

export const useFindPetsByStatus = <
  TData = Awaited<ReturnType<typeof findPetsByStatus>>,
  TError = void
>(
  params: FindPetsByStatusParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof findPetsByStatus>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindPetsByStatusQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findPetsByStatus>>> = ({ signal }) =>
    findPetsByStatus(params, signal);

  const query = useQuery<Awaited<ReturnType<typeof findPetsByStatus>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
 * @deprecated
 * @summary Finds Pets by tags
 */
export const findPetsByTags = (params: FindPetsByTagsParams, signal?: AbortSignal) => {
  return customInstance<Pet[]>({ url: `/pet/findByTags`, method: 'get', params, signal });
};

export const getFindPetsByTagsQueryKey = (params: FindPetsByTagsParams) => [
  `/pet/findByTags`,
  ...(params ? [params] : []),
];

export type FindPetsByTagsQueryResult = NonNullable<Awaited<ReturnType<typeof findPetsByTags>>>;
export type FindPetsByTagsQueryError = void;

export const useFindPetsByTags = <
  TData = Awaited<ReturnType<typeof findPetsByTags>>,
  TError = void
>(
  params: FindPetsByTagsParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof findPetsByTags>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindPetsByTagsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findPetsByTags>>> = ({ signal }) =>
    findPetsByTags(params, signal);

  const query = useQuery<Awaited<ReturnType<typeof findPetsByTags>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Returns a single pet
 * @summary Find pet by ID
 */
export const getPetById = (petId: number, signal?: AbortSignal) => {
  return customInstance<Pet>({ url: `/pet/${petId}`, method: 'get', signal });
};

export const getGetPetByIdQueryKey = (petId: number) => [`/pet/${petId}`];

export type GetPetByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPetById>>>;
export type GetPetByIdQueryError = void;

export const useGetPetById = <TData = Awaited<ReturnType<typeof getPetById>>, TError = void>(
  petId: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPetById>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPetByIdQueryKey(petId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPetById>>> = ({ signal }) =>
    getPetById(petId, signal);

  const query = useQuery<Awaited<ReturnType<typeof getPetById>>, TError, TData>(queryKey, queryFn, {
    enabled: !!petId,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Updates a pet in the store with form data
 */
export const updatePetWithForm = (petId: number, updatePetWithFormBody: UpdatePetWithFormBody) => {
  const formUrlEncoded = new URLSearchParams();
  if (updatePetWithFormBody.name !== undefined) {
    formUrlEncoded.append('name', updatePetWithFormBody.name);
  }
  if (updatePetWithFormBody.status !== undefined) {
    formUrlEncoded.append('status', updatePetWithFormBody.status);
  }

  return customInstance<unknown>({
    url: `/pet/${petId}`,
    method: 'post',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    data: formUrlEncoded,
  });
};

export type UpdatePetWithFormMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePetWithForm>>
>;
export type UpdatePetWithFormMutationBody = UpdatePetWithFormBody;
export type UpdatePetWithFormMutationError = void;

export const useUpdatePetWithForm = <TError = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePetWithForm>>,
    TError,
    { petId: number; data: UpdatePetWithFormBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePetWithForm>>,
    { petId: number; data: UpdatePetWithFormBody }
  > = (props) => {
    const { petId, data } = props ?? {};

    return updatePetWithForm(petId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof updatePetWithForm>>,
    TError,
    { petId: number; data: UpdatePetWithFormBody },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * @summary Deletes a pet
 */
export const deletePet = (petId: number) => {
  return customInstance<unknown>({ url: `/pet/${petId}`, method: 'delete' });
};

export type DeletePetMutationResult = NonNullable<Awaited<ReturnType<typeof deletePet>>>;

export type DeletePetMutationError = void;

export const useDeletePet = <TError = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePet>>,
    TError,
    { petId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePet>>, { petId: number }> = (
    props
  ) => {
    const { petId } = props ?? {};

    return deletePet(petId);
  };

  return useMutation<Awaited<ReturnType<typeof deletePet>>, TError, { petId: number }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * @summary Place an order for a pet
 */
export const placeOrder = (order: Order) => {
  return customInstance<Order>({
    url: `/store/order`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: order,
  });
};

export type PlaceOrderMutationResult = NonNullable<Awaited<ReturnType<typeof placeOrder>>>;
export type PlaceOrderMutationBody = Order;
export type PlaceOrderMutationError = void;

export const usePlaceOrder = <TError = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof placeOrder>>,
    TError,
    { data: Order },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof placeOrder>>, { data: Order }> = (
    props
  ) => {
    const { data } = props ?? {};

    return placeOrder(data);
  };

  return useMutation<Awaited<ReturnType<typeof placeOrder>>, TError, { data: Order }, TContext>(
    mutationFn,
    mutationOptions
  );
};

/**
 * For valid response try integer IDs with value >= 1 and <= 10. Other values will generated exceptions
 * @summary Find purchase order by ID
 */
export const getOrderById = (orderId: number, signal?: AbortSignal) => {
  return customInstance<Order>({ url: `/store/order/${orderId}`, method: 'get', signal });
};

export const getGetOrderByIdQueryKey = (orderId: number) => [`/store/order/${orderId}`];

export type GetOrderByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderById>>>;
export type GetOrderByIdQueryError = void;

export const useGetOrderById = <TData = Awaited<ReturnType<typeof getOrderById>>, TError = void>(
  orderId: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetOrderByIdQueryKey(orderId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderById>>> = ({ signal }) =>
    getOrderById(orderId, signal);

  const query = useQuery<Awaited<ReturnType<typeof getOrderById>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!orderId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors
 * @summary Delete purchase order by ID
 */
export const deleteOrder = (orderId: number) => {
  return customInstance<unknown>({ url: `/store/order/${orderId}`, method: 'delete' });
};

export type DeleteOrderMutationResult = NonNullable<Awaited<ReturnType<typeof deleteOrder>>>;

export type DeleteOrderMutationError = void;

export const useDeleteOrder = <TError = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteOrder>>,
    TError,
    { orderId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteOrder>>,
    { orderId: number }
  > = (props) => {
    const { orderId } = props ?? {};

    return deleteOrder(orderId);
  };

  return useMutation<
    Awaited<ReturnType<typeof deleteOrder>>,
    TError,
    { orderId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Returns a map of status codes to quantities
 * @summary Returns pet inventories by status
 */
export const getInventory = (signal?: AbortSignal) => {
  return customInstance<GetInventory200>({ url: `/store/inventory`, method: 'get', signal });
};

export const getGetInventoryQueryKey = () => [`/store/inventory`];

export type GetInventoryQueryResult = NonNullable<Awaited<ReturnType<typeof getInventory>>>;
export type GetInventoryQueryError = unknown;

export const useGetInventory = <
  TData = Awaited<ReturnType<typeof getInventory>>,
  TError = unknown
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getInventory>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInventoryQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInventory>>> = ({ signal }) =>
    getInventory(signal);

  const query = useQuery<Awaited<ReturnType<typeof getInventory>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Creates list of users with given input array
 */
export const createUsersWithArrayInput = (userArrayBody: UserArrayBody) => {
  return customInstance<unknown>({
    url: `/user/createWithArray`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: userArrayBody,
  });
};

export type CreateUsersWithArrayInputMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUsersWithArrayInput>>
>;
export type CreateUsersWithArrayInputMutationBody = UserArrayBody;
export type CreateUsersWithArrayInputMutationError = void;

export const useCreateUsersWithArrayInput = <TError = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUsersWithArrayInput>>,
    TError,
    { data: UserArrayBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUsersWithArrayInput>>,
    { data: UserArrayBody }
  > = (props) => {
    const { data } = props ?? {};

    return createUsersWithArrayInput(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof createUsersWithArrayInput>>,
    TError,
    { data: UserArrayBody },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * @summary Creates list of users with given input array
 */
export const createUsersWithListInput = (userArrayBody: UserArrayBody) => {
  return customInstance<unknown>({
    url: `/user/createWithList`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: userArrayBody,
  });
};

export type CreateUsersWithListInputMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUsersWithListInput>>
>;
export type CreateUsersWithListInputMutationBody = UserArrayBody;
export type CreateUsersWithListInputMutationError = void;

export const useCreateUsersWithListInput = <TError = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUsersWithListInput>>,
    TError,
    { data: UserArrayBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUsersWithListInput>>,
    { data: UserArrayBody }
  > = (props) => {
    const { data } = props ?? {};

    return createUsersWithListInput(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof createUsersWithListInput>>,
    TError,
    { data: UserArrayBody },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * @summary Get user by user name
 */
export const getUserByName = (username: string, signal?: AbortSignal) => {
  return customInstance<User>({ url: `/user/${username}`, method: 'get', signal });
};

export const getGetUserByNameQueryKey = (username: string) => [`/user/${username}`];

export type GetUserByNameQueryResult = NonNullable<Awaited<ReturnType<typeof getUserByName>>>;
export type GetUserByNameQueryError = void;

export const useGetUserByName = <TData = Awaited<ReturnType<typeof getUserByName>>, TError = void>(
  username: string,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUserByName>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserByNameQueryKey(username);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserByName>>> = ({ signal }) =>
    getUserByName(username, signal);

  const query = useQuery<Awaited<ReturnType<typeof getUserByName>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!username, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * This can only be done by the logged in user.
 * @summary Updated user
 */
export const updateUser = (username: string, user: User) => {
  return customInstance<unknown>({
    url: `/user/${username}`,
    method: 'put',
    headers: { 'Content-Type': 'application/json' },
    data: user,
  });
};

export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>;
export type UpdateUserMutationBody = User;
export type UpdateUserMutationError = void;

export const useUpdateUser = <TError = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { username: string; data: User },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUser>>,
    { username: string; data: User }
  > = (props) => {
    const { username, data } = props ?? {};

    return updateUser(username, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { username: string; data: User },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * This can only be done by the logged in user.
 * @summary Delete user
 */
export const deleteUser = (username: string) => {
  return customInstance<unknown>({ url: `/user/${username}`, method: 'delete' });
};

export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>;

export type DeleteUserMutationError = void;

export const useDeleteUser = <TError = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUser>>,
    TError,
    { username: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUser>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return deleteUser(username);
  };

  return useMutation<
    Awaited<ReturnType<typeof deleteUser>>,
    TError,
    { username: string },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * @summary Logs user into the system
 */
export const loginUser = (params: LoginUserParams, signal?: AbortSignal) => {
  return customInstance<string>({ url: `/user/login`, method: 'get', params, signal });
};

export const getLoginUserQueryKey = (params: LoginUserParams) => [
  `/user/login`,
  ...(params ? [params] : []),
];

export type LoginUserQueryResult = NonNullable<Awaited<ReturnType<typeof loginUser>>>;
export type LoginUserQueryError = void;

export const useLoginUser = <TData = Awaited<ReturnType<typeof loginUser>>, TError = void>(
  params: LoginUserParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof loginUser>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLoginUserQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof loginUser>>> = ({ signal }) =>
    loginUser(params, signal);

  const query = useQuery<Awaited<ReturnType<typeof loginUser>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Logs out current logged in user session
 */
export const logoutUser = (signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/user/logout`, method: 'get', signal });
};

export const getLogoutUserQueryKey = () => [`/user/logout`];

export type LogoutUserQueryResult = NonNullable<Awaited<ReturnType<typeof logoutUser>>>;
export type LogoutUserQueryError = void;

export const useLogoutUser = <
  TData = Awaited<ReturnType<typeof logoutUser>>,
  TError = void
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof logoutUser>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogoutUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logoutUser>>> = ({ signal }) =>
    logoutUser(signal);

  const query = useQuery<Awaited<ReturnType<typeof logoutUser>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * This can only be done by the logged in user.
 * @summary Create user
 */
export const createUser = (user: User) => {
  return customInstance<unknown>({
    url: `/user`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: user,
  });
};

export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>;
export type CreateUserMutationBody = User;
export type CreateUserMutationError = void;

export const useCreateUser = <TError = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: User },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, { data: User }> = (
    props
  ) => {
    const { data } = props ?? {};

    return createUser(data);
  };

  return useMutation<Awaited<ReturnType<typeof createUser>>, TError, { data: User }, TContext>(
    mutationFn,
    mutationOptions
  );
};
